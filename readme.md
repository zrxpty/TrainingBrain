
---

## 🔹 1. `Semaphore`

* Классический семафор, пришёл ещё из WinAPI.
* Может работать **между процессами** (если указываешь имя).
* Создаётся с **максимальным количеством разрешений** и **текущим количеством**.
* Можно делиться между разными приложениями.

```csharp
var semaphore = new Semaphore(initialCount: 2, maximumCount: 5, "Global/MySemaphore");
```

---

## 🔹 2. `SemaphoreSlim`

* Более лёгкая и современная версия.
* Работает только **внутри одного процесса**.
* Поддерживает `async/await` (`WaitAsync`), чего у обычного `Semaphore` нет.
* Используется чаще, чем `Semaphore`.

```csharp
var semaphore = new SemaphoreSlim(initialCount: 2, maxCount: 5);

await semaphore.WaitAsync();
// критическая секция
semaphore.Release();
```

---

## ⚖️ Сравнение

|                    | Semaphore       | SemaphoreSlim    |
| ------------------ | --------------- | ---------------- |
| Межпроцессный      | ✅ Да            | ❌ Нет            |
| Поддержка async    | ❌ Нет           | ✅ Да             |
| Лёгкий по ресурсам | ❌ Более тяжёлый | ✅ Более быстрый  |
| Где применять      | OS-level, IPC   | Внутри .NET кода |

---

👉 То есть в реальной жизни ты используешь почти всегда **`SemaphoreSlim`**, а `Semaphore` нужен, если прям реально надо синхронизировать процессы на уровне ОС.

---

Хочешь, я накидаю **короткий пример с `SemaphoreSlim` и параллельными задачами**, где видно, что только 2 потока одновременно могут заходить в секцию?


Где применяют семафоры

🔄 Ограничить количество параллельных задач (например, максимум 5 запросов к API одновременно).

🗄️ Контроль доступа к ресурсу, который допускает несколько читателей, но не бесконечно.

🧵 В системах с большим количеством потоков, чтобы они не перегружали CPU или базу данных.

🔹 В чём отличие от lock

lock (или Monitor) пропускает только 1 поток — это мьютекс.

Semaphore может пропускать несколько потоков одновременно.

То есть семафор = «мьютекс на N потоков».